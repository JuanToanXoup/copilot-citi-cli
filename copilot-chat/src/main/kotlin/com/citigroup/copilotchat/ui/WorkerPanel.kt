package com.citigroup.copilotchat.ui

import com.citigroup.copilotchat.config.CopilotChatSettings
import com.citigroup.copilotchat.config.CopilotChatSettings.WorkerEntry
import com.citigroup.copilotchat.conversation.ConversationManager
import com.citigroup.copilotchat.orchestrator.*
import com.intellij.icons.AllIcons
import com.intellij.openapi.Disposable
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.DialogWrapper
import com.intellij.openapi.ui.Messages
import com.intellij.ui.JBColor
import com.intellij.ui.components.JBScrollPane
import com.intellij.ui.components.JBTextField
import com.intellij.util.ui.JBUI
import kotlinx.coroutines.*
import java.awt.*
import java.util.*
import javax.swing.*

/**
 * Panel for managing worker agents and orchestrating tasks across them.
 * Each worker is an independent conversation with a specialized role.
 */
class WorkerPanel(private val project: Project) : JPanel(BorderLayout()), Disposable {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)

    // Worker list on the left
    private val workerListModel = DefaultListModel<WorkerState>()
    private val workerList = JList(workerListModel)

    // Orchestrator input at top
    private val orchestrateField = JBTextField()
    private val orchestrateButton = JButton("Orchestrate")
    private val cancelButton = JButton("Cancel").apply { isVisible = false }

    // Worker output area on the right
    private val outputArea = JTextArea().apply {
        isEditable = false
        lineWrap = true
        wrapStyleWord = true
        font = Font(Font.MONOSPACED, Font.PLAIN, 12)
    }

    // Worker task input at bottom
    private val taskField = JBTextField()
    private val sendTaskButton = JButton(AllIcons.Actions.Execute)

    // Per-worker sessions for direct task sends
    private val workerSessions = mutableMapOf<String, WorkerSession>()

    data class WorkerState(
        val entry: WorkerEntry,
        var status: String = "idle",
        val output: StringBuilder = StringBuilder(),
        val isAutoGenerated: Boolean = false,
    ) {
        override fun toString() = "[${status}] ${entry.role}"
    }

    init {
        border = JBUI.Borders.empty(4)

        // === Top: Orchestrator bar ===
        val buttonPanel = JPanel().apply {
            layout = BoxLayout(this, BoxLayout.X_AXIS)
            add(orchestrateButton)
            add(cancelButton)
        }
        val orchestratorBar = JPanel(BorderLayout()).apply {
            border = JBUI.Borders.empty(4)
            add(JLabel("Goal: "), BorderLayout.WEST)
            add(orchestrateField, BorderLayout.CENTER)
            add(buttonPanel, BorderLayout.EAST)
        }
        orchestrateButton.addActionListener { orchestrate() }
        cancelButton.addActionListener { cancelOrchestration() }

        // === Left: Worker list ===
        workerList.cellRenderer = WorkerCellRenderer()
        workerList.selectionMode = ListSelectionModel.SINGLE_SELECTION
        workerList.addListSelectionListener { showWorkerOutput() }

        val workerListPanel = JPanel(BorderLayout()).apply {
            preferredSize = Dimension(200, 0)
            val header = JPanel(BorderLayout()).apply {
                add(JLabel("Workers"), BorderLayout.WEST)
                val btns = JPanel().apply {
                    layout = BoxLayout(this, BoxLayout.X_AXIS)
                    add(JButton(AllIcons.General.Add).apply {
                        toolTipText = "Add Worker"
                        addActionListener { addWorker() }
                    })
                    add(JButton(AllIcons.General.Remove).apply {
                        toolTipText = "Remove Selected"
                        addActionListener { removeWorker() }
                    })
                }
                add(btns, BorderLayout.EAST)
            }
            add(header, BorderLayout.NORTH)
            add(JBScrollPane(workerList), BorderLayout.CENTER)
        }

        // === Right: Output + task input ===
        val outputPanel = JPanel(BorderLayout()).apply {
            add(JBScrollPane(outputArea), BorderLayout.CENTER)
            val taskBar = JPanel(BorderLayout()).apply {
                border = JBUI.Borders.customLine(JBColor.border(), 1, 0, 0, 0)
                add(taskField, BorderLayout.CENTER)
                add(sendTaskButton, BorderLayout.EAST)
            }
            add(taskBar, BorderLayout.SOUTH)
        }
        sendTaskButton.addActionListener { sendTaskToWorker() }

        // === Layout ===
        val splitPane = JSplitPane(JSplitPane.HORIZONTAL_SPLIT, workerListPanel, outputPanel).apply {
            dividerLocation = 200
        }

        add(orchestratorBar, BorderLayout.NORTH)
        add(splitPane, BorderLayout.CENTER)

        loadWorkersFromSettings()
    }

    private fun loadWorkersFromSettings() {
        workerListModel.clear()
        CopilotChatSettings.getInstance().workers.filter { it.enabled }.forEach {
            workerListModel.addElement(WorkerState(it))
        }
    }

    private fun addWorker() {
        val dialog = WorkerDialog(null)
        if (dialog.showAndGet()) {
            val entry = dialog.result!!
            CopilotChatSettings.getInstance().workers.add(entry)
            workerListModel.addElement(WorkerState(entry))
        }
    }

    private fun removeWorker() {
        val idx = workerList.selectedIndex
        if (idx < 0) return
        val ws = workerListModel.getElementAt(idx)
        if (Messages.showYesNoDialog(
                "Remove worker '${ws.entry.role}'?",
                "Remove Worker",
                Messages.getQuestionIcon()
            ) == Messages.YES
        ) {
            CopilotChatSettings.getInstance().workers.remove(ws.entry)
            workerListModel.remove(idx)
        }
    }

    private fun showWorkerOutput() {
        val idx = workerList.selectedIndex
        if (idx < 0) {
            outputArea.text = ""
            return
        }
        val ws = workerListModel.getElementAt(idx)
        outputArea.text = ws.output.toString()
    }

    /**
     * Send a task directly to the selected worker using an isolated WorkerSession.
     */
    private fun sendTaskToWorker() {
        val idx = workerList.selectedIndex
        if (idx < 0) {
            Messages.showWarningDialog("Select a worker first.", "No Worker Selected")
            return
        }
        val task = taskField.text.trim()
        if (task.isEmpty()) return
        taskField.text = ""

        val ws = workerListModel.getElementAt(idx)
        ws.status = "working"
        ws.output.append("\n--- Task: $task ---\n")
        outputArea.text = ws.output.toString()
        workerList.repaint()

        // Get or create an isolated WorkerSession for this worker
        val session = workerSessions.getOrPut(ws.entry.role) {
            WorkerSession(
                workerId = "${ws.entry.role}-direct-${UUID.randomUUID().toString().take(6)}",
                role = ws.entry.role,
                systemPrompt = ws.entry.systemPrompt,
                model = ws.entry.model.ifBlank { CopilotChatSettings.getInstance().defaultModel },
                agentMode = ws.entry.agentMode,
                toolsEnabled = ws.entry.toolsEnabled,
                projectName = project.name,
                workspaceRoot = project.basePath ?: "/tmp",
            ).also { session ->
                session.onEvent = { event ->
                    SwingUtilities.invokeLater {
                        when (event) {
                            is WorkerEvent.Delta -> {
                                ws.output.append(event.text)
                                if (workerList.selectedIndex == idx) {
                                    outputArea.text = ws.output.toString()
                                    outputArea.caretPosition = outputArea.document.length
                                }
                            }
                            is WorkerEvent.ToolCall -> {
                                ws.output.append("\n[tool] ${event.toolName}\n")
                            }
                            is WorkerEvent.Done -> {
                                ws.status = "idle"
                                ws.output.append("\n--- Done ---\n")
                                workerList.repaint()
                                if (workerList.selectedIndex == idx) {
                                    outputArea.text = ws.output.toString()
                                }
                            }
                            is WorkerEvent.Error -> {
                                ws.status = "error"
                                ws.output.append("\n[error] ${event.message}\n")
                                workerList.repaint()
                            }
                        }
                    }
                }
            }
        }

        scope.launch {
            try {
                ConversationManager.getInstance(project).ensureInitialized()
                session.executeTask(task)
            } catch (e: CancellationException) {
                throw e
            } catch (e: Exception) {
                SwingUtilities.invokeLater {
                    ws.status = "error"
                    ws.output.append("\n[error] ${e.message}\n")
                    workerList.repaint()
                    if (workerList.selectedIndex == idx) {
                        outputArea.text = ws.output.toString()
                    }
                }
            }
        }
    }

    /**
     * Orchestrate a goal across all workers using OrchestratorService.
     * Delegates planning, parallel DAG execution, and synthesis to the service.
     */
    private fun orchestrate() {
        val goal = orchestrateField.text.trim()
        if (goal.isEmpty()) return

        val orchestrator = OrchestratorService.getInstance(project)
        if (orchestrator.isRunning) {
            Messages.showInfoMessage("Orchestration already in progress.", "Busy")
            return
        }

        // Reset all worker states
        for (i in 0 until workerListModel.size()) {
            val ws = workerListModel.getElementAt(i)
            ws.status = "idle"
            ws.output.clear()
        }
        workerList.repaint()

        // Show cancel button
        orchestrateButton.isVisible = false
        cancelButton.isVisible = true

        // Collect orchestrator events for UI updates
        scope.launch {
            orchestrator.events.collect { event ->
                SwingUtilities.invokeLater {
                    handleOrchestratorEvent(event)
                }
            }
        }

        orchestrator.run(goal)
    }

    private fun cancelOrchestration() {
        OrchestratorService.getInstance(project).cancel()
        orchestrateButton.isVisible = true
        cancelButton.isVisible = false

        for (i in 0 until workerListModel.size()) {
            val ws = workerListModel.getElementAt(i)
            if (ws.status == "working") {
                ws.status = "idle"
                ws.output.append("\n--- Cancelled ---\n")
            }
        }
        workerList.repaint()
        showWorkerOutput()
    }

    private fun handleOrchestratorEvent(event: OrchestratorEvent) {
        when (event) {
            is OrchestratorEvent.PlanStarted -> {
                outputArea.text = "Planning task decomposition for: ${event.goal}\n"
            }
            is OrchestratorEvent.WorkersGenerated -> {
                // Clear old auto-generated workers, keep manual ones
                val manualWorkers = mutableListOf<WorkerState>()
                for (i in 0 until workerListModel.size()) {
                    val ws = workerListModel.getElementAt(i)
                    if (!ws.isAutoGenerated) manualWorkers.add(ws)
                }
                workerListModel.clear()
                manualWorkers.forEach { workerListModel.addElement(it) }

                // Add auto-generated workers
                val existingRoles = manualWorkers.map { it.entry.role }.toSet()
                for (worker in event.workers) {
                    if (worker.role !in existingRoles) {
                        workerListModel.addElement(WorkerState(worker, isAutoGenerated = true))
                    }
                }
                workerList.repaint()

                val autoCount = event.workers.count { it.role !in existingRoles }
                outputArea.text = outputArea.text +
                    "Auto-generated $autoCount worker(s): ${event.workers.map { it.role }}\n"
            }
            is OrchestratorEvent.PlanCompleted -> {
                val planText = event.tasks.joinToString("\n") { t ->
                    val deps = if (t.dependsOn.isNotEmpty()) " (after: ${t.dependsOn})" else ""
                    "  ${t.index}. [${t.workerRole}]$deps ${t.task}"
                }
                outputArea.text = outputArea.text + "\nPlan (${event.tasks.size} tasks):\n$planText\n\n"
            }
            is OrchestratorEvent.TaskAssigned -> {
                val ws = findWorkerState(event.task.workerRole)
                if (ws != null) {
                    ws.status = "working"
                    ws.output.append("--- Task ${event.task.index}: ${event.task.task} ---\n")
                    workerList.repaint()
                }
            }
            is OrchestratorEvent.TaskProgress -> {
                val ws = findWorkerState(event.workerRole)
                if (ws != null) {
                    ws.output.append(event.text)
                    // If this worker is selected, update the display
                    val selectedWs = workerList.selectedValue
                    if (selectedWs?.entry?.role == event.workerRole) {
                        outputArea.text = ws.output.toString()
                        outputArea.caretPosition = outputArea.document.length
                    }
                }
            }
            is OrchestratorEvent.TaskCompleted -> {
                val ws = findWorkerState(event.result.workerRole)
                if (ws != null) {
                    ws.status = if (event.result.status == "success") "done" else "error"
                    ws.output.append("\n--- Task ${event.result.index} ${event.result.status} ---\n")
                    workerList.repaint()
                }
            }
            is OrchestratorEvent.SummarizeStarted -> {
                outputArea.text = outputArea.text + "\nGenerating summary...\n"
            }
            is OrchestratorEvent.SummarizeCompleted -> {
                outputArea.text = outputArea.text + "\n=== Summary ===\n${event.summary}\n"
            }
            is OrchestratorEvent.Finished -> {
                orchestrateButton.isVisible = true
                cancelButton.isVisible = false

                // Update all workers to final state
                for (i in 0 until workerListModel.size()) {
                    val ws = workerListModel.getElementAt(i)
                    if (ws.status == "working") ws.status = "done"
                }
                workerList.repaint()
            }
            is OrchestratorEvent.Error -> {
                outputArea.text = outputArea.text + "\n[ERROR] ${event.message}\n"
                orchestrateButton.isVisible = true
                cancelButton.isVisible = false
            }
            is OrchestratorEvent.TaskSkipped -> {
                val ws = findWorkerState(event.task.workerRole)
                if (ws != null) {
                    ws.status = "skipped"
                    ws.output.append("\n--- Task ${event.task.index} skipped ---\n${event.result.result}\n")
                    workerList.repaint()
                }
                outputArea.text = outputArea.text + "\n[SKIPPED] Task ${event.task.index} (${event.task.workerRole}): ${event.result.result}\n"
            }
            is OrchestratorEvent.Deadlock -> {
                outputArea.text = outputArea.text + "\n[DAG DEADLOCK] Pending: ${event.pending}, Completed: ${event.completed}\n"
            }
            is OrchestratorEvent.SupervisorEvaluating -> {
                outputArea.text = outputArea.text + "\n[SUPERVISOR] Evaluating (iteration ${event.iteration})...\n"
            }
            is OrchestratorEvent.SupervisorVerdictEvent -> {
                outputArea.text = outputArea.text + "[SUPERVISOR] ${event.decision}: ${event.reasoning}\n"
            }
            is OrchestratorEvent.FollowUpPlanned -> {
                val taskList = event.tasks.joinToString("\n") { t ->
                    "  ${t.index}. [${t.workerRole}] ${t.task}"
                }
                outputArea.text = outputArea.text + "\nFollow-up tasks:\n$taskList\n"
            }
            is OrchestratorEvent.WaitingForUser -> {
                outputArea.text = outputArea.text + "\n[WAITING] Supervisor question: ${event.question}\n"
            }
            is OrchestratorEvent.UserResponded -> {
                outputArea.text = outputArea.text + "[USER] ${event.response}\n"
            }
        }
    }

    private fun findWorkerState(role: String): WorkerState? {
        for (i in 0 until workerListModel.size()) {
            val ws = workerListModel.getElementAt(i)
            if (ws.entry.role == role) return ws
        }
        return null
    }

    private class WorkerCellRenderer : DefaultListCellRenderer() {
        override fun getListCellRendererComponent(
            list: JList<*>, value: Any?, index: Int, isSelected: Boolean, cellHasFocus: Boolean
        ): Component {
            super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus)
            val ws = value as? WorkerState ?: return this
            val statusColor = when (ws.status) {
                "working" -> "#FF9800"
                "error" -> "#F44336"
                "done" -> "#2196F3"
                else -> "#4CAF50"
            }
            val autoTag = if (ws.isAutoGenerated) " <span style='color: #888'>(auto)</span>" else ""
            text = "<html><b>${ws.entry.role}</b>$autoTag <span style='color: $statusColor'>[${ws.status}]</span></html>"
            icon = when (ws.status) {
                "working" -> AllIcons.Process.Step_1
                "error" -> AllIcons.General.Error
                "done" -> AllIcons.Actions.Checked
                else -> if (ws.isAutoGenerated) AllIcons.Nodes.Plugin else AllIcons.Nodes.Deploy
            }
            return this
        }
    }

    override fun dispose() {
        workerSessions.clear()
        scope.cancel()
    }
}

/**
 * Dialog for adding/editing a worker agent.
 */
class WorkerDialog(private val existing: WorkerEntry?) : DialogWrapper(true) {
    var result: WorkerEntry? = null
        private set

    private val roleField = JBTextField(existing?.role ?: "")
    private val descField = JBTextField(existing?.description ?: "")
    private val modelField = JBTextField(existing?.model ?: "")
    private val promptArea = JTextArea(existing?.systemPrompt ?: "", 5, 40)
    private val agentModeCheckbox = JCheckBox("Agent Mode (tool calling)", existing?.agentMode ?: true)
    private val toolsEnabledArea = JTextArea(
        existing?.toolsEnabled?.joinToString(", ") ?: "", 2, 40
    )

    init {
        title = if (existing != null) "Edit Worker" else "Add Worker"
        init()
    }

    override fun createCenterPanel(): JComponent {
        val panel = JPanel(GridBagLayout())
        val gbc = GridBagConstraints().apply {
            fill = GridBagConstraints.HORIZONTAL
            insets = JBUI.insets(4)
            weightx = 1.0
        }

        var row = 0
        fun addRow(label: String, comp: JComponent) {
            gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0.0
            panel.add(JLabel(label), gbc)
            gbc.gridx = 1; gbc.weightx = 1.0
            panel.add(comp, gbc)
            row++
        }

        addRow("Role:", roleField)
        addRow("Description:", descField)
        addRow("Model:", modelField)

        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0.0
        panel.add(JLabel("System Prompt:"), gbc)
        gbc.gridx = 1; gbc.weightx = 1.0
        val promptScroll = JBScrollPane(promptArea)
        promptScroll.preferredSize = Dimension(400, 100)
        panel.add(promptScroll, gbc)
        row++

        addRow("", agentModeCheckbox)

        gbc.gridx = 0; gbc.gridy = row; gbc.weightx = 0.0
        panel.add(JLabel("Tools Enabled:"), gbc)
        gbc.gridx = 1; gbc.weightx = 1.0
        val toolsScroll = JBScrollPane(toolsEnabledArea)
        toolsScroll.preferredSize = Dimension(400, 50)
        panel.add(toolsScroll, gbc)
        row++

        // Hints
        gbc.gridx = 0; gbc.gridy = row; gbc.gridwidth = 2
        panel.add(JLabel("<html><i style='color: gray'>Tools: comma-separated names, blank = all tools. " +
            "Examples: read_file, grep_search, list_dir</i></html>"), gbc)
        row++

        gbc.gridy = row; gbc.gridwidth = 2
        panel.add(JLabel("<html><i style='color: gray'>Presets: bug_fixer, test_writer, code_reviewer, playwright_tester</i></html>"), gbc)

        return panel
    }

    override fun doOKAction() {
        if (roleField.text.isBlank()) {
            Messages.showErrorDialog("Worker role is required.", "Validation Error")
            return
        }

        val toolsText = toolsEnabledArea.text.trim()
        val toolsList: MutableList<String>? = if (toolsText.isBlank()) {
            null // null = all tools
        } else {
            toolsText.split(",").map { it.trim() }.filter { it.isNotEmpty() }.toMutableList()
        }

        result = WorkerEntry(
            role = roleField.text.trim(),
            description = descField.text.trim(),
            model = modelField.text.trim(),
            systemPrompt = promptArea.text.trim(),
            enabled = true,
            toolsEnabled = toolsList,
            agentMode = agentModeCheckbox.isSelected,
        )
        super.doOKAction()
    }
}